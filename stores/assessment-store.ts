import { create } from 'zustand'
import { persist } from 'zustand/middleware'
import type { Assessment, VulnerabilityAudit, AIPolicyLevel, AssessmentType, AssessmentFormat } from '@/types/schema'

// Alternative assessment suggestion from AI
export interface AlternativeAssessment {
  id: string
  original_assessment_id: string
  name: string
  type: AssessmentType
  description: string
  authenticity_features: string[]
  ai_policy?: AIPolicyLevel
  rationale: string
  accepted: boolean
}

interface AssessmentState {
  // Assessments map
  assessments: Map<string, Assessment>

  // Currently selected assessment for editing/viewing
  selectedAssessmentId: string | null

  // Alternative assessments generated by AI
  alternatives: Map<string, AlternativeAssessment[]>

  // Loading states
  isAuditing: boolean
  isGeneratingAlternatives: boolean

  // Actions - CRUD
  setAssessments: (assessments: Assessment[]) => void
  addAssessment: (assessment: Assessment) => void
  updateAssessment: (id: string, updates: Partial<Assessment>) => void
  removeAssessment: (id: string) => void
  clearAssessments: () => void

  // Selection
  setSelectedAssessmentId: (id: string | null) => void

  // Vulnerability audit
  setVulnerabilityAudit: (assessmentId: string, audit: VulnerabilityAudit) => void
  clearVulnerabilityAudit: (assessmentId: string) => void

  // Alternatives
  setAlternatives: (assessmentId: string, alternatives: AlternativeAssessment[]) => void
  acceptAlternative: (assessmentId: string, alternativeId: string) => void
  clearAlternatives: (assessmentId: string) => void

  // Loading states
  setIsAuditing: (isAuditing: boolean) => void
  setIsGeneratingAlternatives: (isGenerating: boolean) => void

  // Reset
  reset: () => void

  // Partial reset - preserve assessments but clear audits and alternatives (for mode transition)
  clearAlternativesAndAudits: () => void
}

// Helper to generate assessment ID
export function generateAssessmentId(): string {
  return `assessment-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`
}

// Helper to generate alternative ID
export function generateAlternativeId(): string {
  return `alt-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`
}

const initialState = {
  assessments: new Map<string, Assessment>(),
  selectedAssessmentId: null,
  alternatives: new Map<string, AlternativeAssessment[]>(),
  isAuditing: false,
  isGeneratingAlternatives: false,
}

export const useAssessmentStore = create<AssessmentState>()(
  persist(
    (set, get) => ({
      ...initialState,

      setAssessments: (assessments) =>
        set({
          assessments: new Map(assessments.map((a) => [a.id, a])),
        }),

      addAssessment: (assessment) =>
        set((state) => {
          const newAssessments = new Map(state.assessments)
          newAssessments.set(assessment.id, assessment)
          return { assessments: newAssessments }
        }),

      updateAssessment: (id, updates) =>
        set((state) => {
          const assessment = state.assessments.get(id)
          if (!assessment) return state
          const newAssessments = new Map(state.assessments)
          newAssessments.set(id, { ...assessment, ...updates })
          return { assessments: newAssessments }
        }),

      removeAssessment: (id) =>
        set((state) => {
          const newAssessments = new Map(state.assessments)
          newAssessments.delete(id)
          // Also clear alternatives for this assessment
          const newAlternatives = new Map(state.alternatives)
          newAlternatives.delete(id)
          return {
            assessments: newAssessments,
            alternatives: newAlternatives,
            selectedAssessmentId:
              state.selectedAssessmentId === id ? null : state.selectedAssessmentId,
          }
        }),

      clearAssessments: () =>
        set({
          assessments: new Map(),
          alternatives: new Map(),
          selectedAssessmentId: null,
        }),

      setSelectedAssessmentId: (id) => set({ selectedAssessmentId: id }),

      setVulnerabilityAudit: (assessmentId, audit) =>
        set((state) => {
          const assessment = state.assessments.get(assessmentId)
          if (!assessment) return state
          const newAssessments = new Map(state.assessments)
          newAssessments.set(assessmentId, {
            ...assessment,
            vulnerability_audit: audit,
          })
          return { assessments: newAssessments }
        }),

      clearVulnerabilityAudit: (assessmentId) =>
        set((state) => {
          const assessment = state.assessments.get(assessmentId)
          if (!assessment) return state
          const newAssessments = new Map(state.assessments)
          const { vulnerability_audit, ...rest } = assessment
          newAssessments.set(assessmentId, rest as Assessment)
          return { assessments: newAssessments }
        }),

      setAlternatives: (assessmentId, alternatives) =>
        set((state) => {
          const newAlternatives = new Map(state.alternatives)
          newAlternatives.set(assessmentId, alternatives)
          return { alternatives: newAlternatives }
        }),

      acceptAlternative: (assessmentId, alternativeId) =>
        set((state) => {
          const alts = state.alternatives.get(assessmentId)
          if (!alts) return state
          const newAlternatives = new Map(state.alternatives)
          newAlternatives.set(
            assessmentId,
            alts.map((alt) =>
              alt.id === alternativeId ? { ...alt, accepted: true } : alt
            )
          )
          return { alternatives: newAlternatives }
        }),

      clearAlternatives: (assessmentId) =>
        set((state) => {
          const newAlternatives = new Map(state.alternatives)
          newAlternatives.delete(assessmentId)
          return { alternatives: newAlternatives }
        }),

      setIsAuditing: (isAuditing) => set({ isAuditing }),
      setIsGeneratingAlternatives: (isGenerating) =>
        set({ isGeneratingAlternatives: isGenerating }),

      reset: () =>
        set({
          assessments: new Map(),
          selectedAssessmentId: null,
          alternatives: new Map(),
          isAuditing: false,
          isGeneratingAlternatives: false,
        }),

      clearAlternativesAndAudits: () =>
        set((state) => {
          // Clear alternatives map
          const clearedAlternatives = new Map<string, AlternativeAssessment[]>()

          // Remove vulnerability_audit from assessments but keep assessments
          const clearedAssessments = new Map(state.assessments)
          clearedAssessments.forEach((assessment, id) => {
            const { vulnerability_audit, ...rest } = assessment
            clearedAssessments.set(id, rest as Assessment)
          })

          return {
            alternatives: clearedAlternatives,
            assessments: clearedAssessments,
            isAuditing: false,
            isGeneratingAlternatives: false,
          }
        }),
    }),
    {
      name: 'course-architect-assessments',
      storage: {
        getItem: (name) => {
          const str = localStorage.getItem(name)
          if (!str) return null
          const data = JSON.parse(str)
          return {
            ...data,
            state: {
              ...data.state,
              assessments: new Map(data.state.assessments || []),
              alternatives: new Map(data.state.alternatives || []),
            },
          }
        },
        setItem: (name, value) => {
          const data = {
            ...value,
            state: {
              ...value.state,
              assessments: Array.from(value.state.assessments.entries()),
              alternatives: Array.from(value.state.alternatives.entries()),
            },
          }
          localStorage.setItem(name, JSON.stringify(data))
        },
        removeItem: (name) => localStorage.removeItem(name),
      },
    }
  )
)
